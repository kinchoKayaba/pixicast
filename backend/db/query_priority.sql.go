// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_priority.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const calculateSourcePriority = `-- name: CalculateSourcePriority :exec
WITH channel_popularity AS (
    SELECT
        us.source_id,
        COUNT(DISTINCT us.user_id) as subscriber_count,
        MAX(us.last_accessed_at) as last_access
    FROM user_subscriptions us
    WHERE us.enabled = true
    GROUP BY us.source_id
),
total_users AS (
    SELECT COUNT(DISTINCT user_id) as total
    FROM user_subscriptions
    WHERE enabled = true
),
calculated_priority AS (
    SELECT
        s.id as source_id,
        COALESCE(cp.subscriber_count, 0) as subscriber_count,
        CASE
            WHEN tu.total = 0 THEN 0.0
            ELSE CAST(COALESCE(cp.subscriber_count, 0) AS DECIMAL) / CAST(tu.total AS DECIMAL)
        END as popularity_ratio,
        CASE
            WHEN tu.total = 0 THEN 'low'
            WHEN CAST(COALESCE(cp.subscriber_count, 0) AS DECIMAL) / CAST(tu.total AS DECIMAL) >= 0.5 THEN 'high'
            WHEN CAST(COALESCE(cp.subscriber_count, 0) AS DECIMAL) / CAST(tu.total AS DECIMAL) >= 0.1 THEN 'medium'
            ELSE 'low'
        END as priority_level,
        CASE
            WHEN tu.total = 0 THEN 360
            WHEN CAST(COALESCE(cp.subscriber_count, 0) AS DECIMAL) / CAST(tu.total AS DECIMAL) >= 0.5 THEN 60
            WHEN CAST(COALESCE(cp.subscriber_count, 0) AS DECIMAL) / CAST(tu.total AS DECIMAL) >= 0.1 THEN 180
            ELSE 360
        END as update_interval_minutes
    FROM sources s
    CROSS JOIN total_users tu
    LEFT JOIN channel_popularity cp ON s.id = cp.source_id
    WHERE s.platform_id = 'youtube'
        AND s.fetch_status = 'ok'
)
INSERT INTO source_priority (
    source_id,
    subscriber_count,
    popularity_ratio,
    priority_level,
    update_interval_minutes,
    last_calculated_at,
    updated_at
)
SELECT
    source_id,
    subscriber_count,
    popularity_ratio,
    priority_level,
    update_interval_minutes,
    now(),
    now()
FROM calculated_priority
ON CONFLICT (source_id) DO UPDATE SET
    subscriber_count = EXCLUDED.subscriber_count,
    popularity_ratio = EXCLUDED.popularity_ratio,
    priority_level = EXCLUDED.priority_level,
    update_interval_minutes = EXCLUDED.update_interval_minutes,
    last_calculated_at = now(),
    updated_at = now()
`

// 全チャンネルの優先度を計算してsource_priorityテーブルを更新
func (q *Queries) CalculateSourcePriority(ctx context.Context) error {
	_, err := q.db.Exec(ctx, calculateSourcePriority)
	return err
}

const createUpdateSchedule = `-- name: CreateUpdateSchedule :one
INSERT INTO update_schedule (
    source_id,
    scheduled_at,
    priority_level,
    status,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, 'pending', now(), now())
RETURNING id, source_id, scheduled_at, priority_level, status, started_at, completed_at, error_message, created_at, updated_at
`

type CreateUpdateScheduleParams struct {
	SourceID      pgtype.UUID        `json:"source_id"`
	ScheduledAt   pgtype.Timestamptz `json:"scheduled_at"`
	PriorityLevel string             `json:"priority_level"`
}

// 更新スケジュールを作成
func (q *Queries) CreateUpdateSchedule(ctx context.Context, arg CreateUpdateScheduleParams) (UpdateSchedule, error) {
	row := q.db.QueryRow(ctx, createUpdateSchedule, arg.SourceID, arg.ScheduledAt, arg.PriorityLevel)
	var i UpdateSchedule
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.ScheduledAt,
		&i.PriorityLevel,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIQuotaUsageByEndpoint = `-- name: GetAPIQuotaUsageByEndpoint :many
SELECT
    endpoint,
    SUM(quota_cost) as total_quota_cost,
    SUM(request_count) as total_requests
FROM api_quota_usage
WHERE date = $1
    AND platform_id = $2
GROUP BY endpoint
ORDER BY total_quota_cost DESC
`

type GetAPIQuotaUsageByEndpointParams struct {
	Date       pgtype.Date `json:"date"`
	PlatformID string      `json:"platform_id"`
}

type GetAPIQuotaUsageByEndpointRow struct {
	Endpoint       string `json:"endpoint"`
	TotalQuotaCost int64  `json:"total_quota_cost"`
	TotalRequests  int64  `json:"total_requests"`
}

// エンドポイント別のAPI使用量を取得
func (q *Queries) GetAPIQuotaUsageByEndpoint(ctx context.Context, arg GetAPIQuotaUsageByEndpointParams) ([]GetAPIQuotaUsageByEndpointRow, error) {
	rows, err := q.db.Query(ctx, getAPIQuotaUsageByEndpoint, arg.Date, arg.PlatformID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAPIQuotaUsageByEndpointRow{}
	for rows.Next() {
		var i GetAPIQuotaUsageByEndpointRow
		if err := rows.Scan(&i.Endpoint, &i.TotalQuotaCost, &i.TotalRequests); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyAPIQuotaUsage = `-- name: GetDailyAPIQuotaUsage :one
SELECT
    COALESCE(SUM(quota_cost), 0) as total_quota_used,
    COALESCE(SUM(request_count), 0) as total_requests
FROM api_quota_usage
WHERE date = $1
    AND platform_id = $2
`

type GetDailyAPIQuotaUsageParams struct {
	Date       pgtype.Date `json:"date"`
	PlatformID string      `json:"platform_id"`
}

type GetDailyAPIQuotaUsageRow struct {
	TotalQuotaUsed interface{} `json:"total_quota_used"`
	TotalRequests  interface{} `json:"total_requests"`
}

// 日次API使用量を取得
func (q *Queries) GetDailyAPIQuotaUsage(ctx context.Context, arg GetDailyAPIQuotaUsageParams) (GetDailyAPIQuotaUsageRow, error) {
	row := q.db.QueryRow(ctx, getDailyAPIQuotaUsage, arg.Date, arg.PlatformID)
	var i GetDailyAPIQuotaUsageRow
	err := row.Scan(&i.TotalQuotaUsed, &i.TotalRequests)
	return i, err
}

const getHighPrioritySources = `-- name: GetHighPrioritySources :many
SELECT
    s.id,
    s.platform_id,
    s.external_id,
    s.display_name,
    s.uploads_playlist_id,
    s.last_fetched_at
FROM sources s
JOIN source_priority sp ON s.id = sp.source_id
WHERE sp.priority_level = 'high'
    AND s.fetch_status = 'ok'
    AND (
        s.last_fetched_at IS NULL
        OR s.last_fetched_at < now() - interval '60 minutes'
    )
ORDER BY s.last_fetched_at ASC NULLS FIRST
LIMIT $1
`

type GetHighPrioritySourcesRow struct {
	ID                pgtype.UUID        `json:"id"`
	PlatformID        string             `json:"platform_id"`
	ExternalID        string             `json:"external_id"`
	DisplayName       pgtype.Text        `json:"display_name"`
	UploadsPlaylistID pgtype.Text        `json:"uploads_playlist_id"`
	LastFetchedAt     pgtype.Timestamptz `json:"last_fetched_at"`
}

// 高優先度チャンネルのみ取得
func (q *Queries) GetHighPrioritySources(ctx context.Context, limit int32) ([]GetHighPrioritySourcesRow, error) {
	rows, err := q.db.Query(ctx, getHighPrioritySources, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHighPrioritySourcesRow{}
	for rows.Next() {
		var i GetHighPrioritySourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.DisplayName,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSchedules = `-- name: GetPendingSchedules :many
SELECT
    us.id, us.source_id, us.scheduled_at, us.priority_level, us.status, us.started_at, us.completed_at, us.error_message, us.created_at, us.updated_at,
    s.external_id,
    s.platform_id
FROM update_schedule us
JOIN sources s ON us.source_id = s.id
WHERE us.status = 'pending'
    AND us.scheduled_at <= now()
ORDER BY us.priority_level DESC, us.scheduled_at ASC
LIMIT $1
`

type GetPendingSchedulesRow struct {
	ID            pgtype.UUID        `json:"id"`
	SourceID      pgtype.UUID        `json:"source_id"`
	ScheduledAt   pgtype.Timestamptz `json:"scheduled_at"`
	PriorityLevel string             `json:"priority_level"`
	Status        string             `json:"status"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	ErrorMessage  pgtype.Text        `json:"error_message"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ExternalID    string             `json:"external_id"`
	PlatformID    string             `json:"platform_id"`
}

// 実行待ちのスケジュールを取得
func (q *Queries) GetPendingSchedules(ctx context.Context, limit int32) ([]GetPendingSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getPendingSchedules, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingSchedulesRow{}
	for rows.Next() {
		var i GetPendingSchedulesRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.ScheduledAt,
			&i.PriorityLevel,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalID,
			&i.PlatformID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourcePriorityStats = `-- name: GetSourcePriorityStats :many
SELECT
    priority_level,
    COUNT(*) as source_count,
    AVG(subscriber_count) as avg_subscribers,
    AVG(popularity_ratio) as avg_popularity,
    update_interval_minutes
FROM source_priority
GROUP BY priority_level, update_interval_minutes
ORDER BY
    CASE priority_level
        WHEN 'high' THEN 1
        WHEN 'medium' THEN 2
        WHEN 'low' THEN 3
    END
`

type GetSourcePriorityStatsRow struct {
	PriorityLevel         string  `json:"priority_level"`
	SourceCount           int64   `json:"source_count"`
	AvgSubscribers        float64 `json:"avg_subscribers"`
	AvgPopularity         float64 `json:"avg_popularity"`
	UpdateIntervalMinutes int32   `json:"update_interval_minutes"`
}

// 優先度別の統計情報を取得
func (q *Queries) GetSourcePriorityStats(ctx context.Context) ([]GetSourcePriorityStatsRow, error) {
	rows, err := q.db.Query(ctx, getSourcePriorityStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSourcePriorityStatsRow{}
	for rows.Next() {
		var i GetSourcePriorityStatsRow
		if err := rows.Scan(
			&i.PriorityLevel,
			&i.SourceCount,
			&i.AvgSubscribers,
			&i.AvgPopularity,
			&i.UpdateIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourcesByPriority = `-- name: GetSourcesByPriority :many
SELECT
    s.id,
    s.platform_id,
    s.external_id,
    s.display_name,
    s.uploads_playlist_id,
    s.last_fetched_at,
    sp.priority_level,
    sp.subscriber_count,
    sp.popularity_ratio,
    sp.update_interval_minutes
FROM sources s
JOIN source_priority sp ON s.id = sp.source_id
WHERE s.platform_id = $1
    AND s.fetch_status = 'ok'
    AND (
        s.last_fetched_at IS NULL
        OR s.last_fetched_at < now() - (sp.update_interval_minutes || ' minutes')::interval
    )
ORDER BY
    sp.priority_level DESC,
    s.last_fetched_at ASC NULLS FIRST
LIMIT $2
`

type GetSourcesByPriorityParams struct {
	PlatformID string `json:"platform_id"`
	Limit      int32  `json:"limit"`
}

type GetSourcesByPriorityRow struct {
	ID                    pgtype.UUID        `json:"id"`
	PlatformID            string             `json:"platform_id"`
	ExternalID            string             `json:"external_id"`
	DisplayName           pgtype.Text        `json:"display_name"`
	UploadsPlaylistID     pgtype.Text        `json:"uploads_playlist_id"`
	LastFetchedAt         pgtype.Timestamptz `json:"last_fetched_at"`
	PriorityLevel         string             `json:"priority_level"`
	SubscriberCount       int32              `json:"subscriber_count"`
	PopularityRatio       pgtype.Numeric     `json:"popularity_ratio"`
	UpdateIntervalMinutes int32              `json:"update_interval_minutes"`
}

// 優先度別にソースを取得
func (q *Queries) GetSourcesByPriority(ctx context.Context, arg GetSourcesByPriorityParams) ([]GetSourcesByPriorityRow, error) {
	rows, err := q.db.Query(ctx, getSourcesByPriority, arg.PlatformID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSourcesByPriorityRow{}
	for rows.Next() {
		var i GetSourcesByPriorityRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.DisplayName,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.PriorityLevel,
			&i.SubscriberCount,
			&i.PopularityRatio,
			&i.UpdateIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordAPIQuotaUsage = `-- name: RecordAPIQuotaUsage :exec
INSERT INTO api_quota_usage (
    date,
    platform_id,
    endpoint,
    quota_cost,
    request_count,
    created_at
)
VALUES ($1, $2, $3, $4, 1, now())
ON CONFLICT (date, platform_id, endpoint) DO UPDATE SET
    quota_cost = api_quota_usage.quota_cost + EXCLUDED.quota_cost,
    request_count = api_quota_usage.request_count + 1
`

type RecordAPIQuotaUsageParams struct {
	Date       pgtype.Date `json:"date"`
	PlatformID string      `json:"platform_id"`
	Endpoint   string      `json:"endpoint"`
	QuotaCost  int32       `json:"quota_cost"`
}

// API使用量を記録
func (q *Queries) RecordAPIQuotaUsage(ctx context.Context, arg RecordAPIQuotaUsageParams) error {
	_, err := q.db.Exec(ctx, recordAPIQuotaUsage,
		arg.Date,
		arg.PlatformID,
		arg.Endpoint,
		arg.QuotaCost,
	)
	return err
}

const updateScheduleStatus = `-- name: UpdateScheduleStatus :exec
UPDATE update_schedule
SET
    status = $2,
    started_at = CASE WHEN $2 = 'running' THEN now() ELSE started_at END,
    completed_at = CASE WHEN $2 IN ('completed', 'failed') THEN now() ELSE completed_at END,
    error_message = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateScheduleStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

// スケジュールステータスを更新
func (q *Queries) UpdateScheduleStatus(ctx context.Context, arg UpdateScheduleStatusParams) error {
	_, err := q.db.Exec(ctx, updateScheduleStatus, arg.ID, arg.Status, arg.ErrorMessage)
	return err
}
