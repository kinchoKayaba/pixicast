// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_subscriptions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserSubscriptions = `-- name: CountUserSubscriptions :one
SELECT COUNT(*) FROM user_subscriptions
WHERE user_id = $1 AND enabled = true
`

// ============================================================================
// CountUserSubscriptions: ユーザーの購読数をカウント
// ============================================================================
func (q *Queries) CountUserSubscriptions(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSubscriptions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteUserSubscription = `-- name: DeleteUserSubscription :exec
DELETE FROM user_subscriptions
WHERE user_id = $1 AND source_id = $2
`

type DeleteUserSubscriptionParams struct {
	UserID   int64       `json:"user_id"`
	SourceID pgtype.UUID `json:"source_id"`
}

// ============================================================================
// DeleteUserSubscription: 購読を削除
// ============================================================================
func (q *Queries) DeleteUserSubscription(ctx context.Context, arg DeleteUserSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteUserSubscription, arg.UserID, arg.SourceID)
	return err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT user_id, source_id, enabled, priority, created_at, updated_at, is_favorite, last_accessed_at FROM user_subscriptions
WHERE user_id = $1 AND source_id = $2
`

type GetUserSubscriptionParams struct {
	UserID   int64       `json:"user_id"`
	SourceID pgtype.UUID `json:"source_id"`
}

// ============================================================================
// GetUserSubscription: 特定の購読情報を取得
// ============================================================================
func (q *Queries) GetUserSubscription(ctx context.Context, arg GetUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, arg.UserID, arg.SourceID)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.SourceID,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFavorite,
		&i.LastAccessedAt,
	)
	return i, err
}

const listFavoriteSubscriptions = `-- name: ListFavoriteSubscriptions :many
SELECT
    s.id,
    s.platform_id,
    s.external_id,
    s.handle,
    s.display_name,
    s.thumbnail_url,
    s.uploads_playlist_id,
    s.last_fetched_at,
    s.fetch_status,
    s.created_at,
    s.updated_at,
    us.enabled,
    us.is_favorite,
    us.priority,
    us.created_at as subscribed_at
FROM user_subscriptions us
JOIN sources s ON us.source_id = s.id
WHERE us.user_id = $1 AND us.enabled = true AND us.is_favorite = true
ORDER BY us.priority DESC, us.created_at DESC
`

type ListFavoriteSubscriptionsRow struct {
	ID                pgtype.UUID        `json:"id"`
	PlatformID        string             `json:"platform_id"`
	ExternalID        string             `json:"external_id"`
	Handle            pgtype.Text        `json:"handle"`
	DisplayName       pgtype.Text        `json:"display_name"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	UploadsPlaylistID pgtype.Text        `json:"uploads_playlist_id"`
	LastFetchedAt     pgtype.Timestamptz `json:"last_fetched_at"`
	FetchStatus       string             `json:"fetch_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Enabled           bool               `json:"enabled"`
	IsFavorite        bool               `json:"is_favorite"`
	Priority          int32              `json:"priority"`
	SubscribedAt      pgtype.Timestamptz `json:"subscribed_at"`
}

// ============================================================================
// ListFavoriteSubscriptions: お気に入りの購読チャンネル一覧を取得
// ============================================================================
func (q *Queries) ListFavoriteSubscriptions(ctx context.Context, userID int64) ([]ListFavoriteSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listFavoriteSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFavoriteSubscriptionsRow{}
	for rows.Next() {
		var i ListFavoriteSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Enabled,
			&i.IsFavorite,
			&i.Priority,
			&i.SubscribedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscribedSourceIDs = `-- name: ListSubscribedSourceIDs :many
SELECT source_id FROM user_subscriptions
WHERE user_id = $1 AND enabled = true
ORDER BY priority DESC, created_at DESC
`

// ============================================================================
// ListSubscribedSourceIDs: ユーザーが購読中のsource_idリストを取得
// ============================================================================
func (q *Queries) ListSubscribedSourceIDs(ctx context.Context, userID int64) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listSubscribedSourceIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var source_id pgtype.UUID
		if err := rows.Scan(&source_id); err != nil {
			return nil, err
		}
		items = append(items, source_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserEnabledSubscriptions = `-- name: ListUserEnabledSubscriptions :many
SELECT 
    s.id,
    s.platform_id,
    s.external_id,
    s.handle,
    s.display_name,
    s.thumbnail_url,
    s.uploads_playlist_id,
    s.fetch_status,
    s.last_fetched_at,
    s.created_at,
    s.updated_at,
    us.enabled,
    us.is_favorite,
    us.priority,
    us.created_at as subscribed_at
FROM user_subscriptions us
JOIN sources s ON us.source_id = s.id
WHERE us.user_id = $1 AND us.enabled = true
ORDER BY us.priority DESC, us.created_at DESC
`

type ListUserEnabledSubscriptionsRow struct {
	ID                pgtype.UUID        `json:"id"`
	PlatformID        string             `json:"platform_id"`
	ExternalID        string             `json:"external_id"`
	Handle            pgtype.Text        `json:"handle"`
	DisplayName       pgtype.Text        `json:"display_name"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	UploadsPlaylistID pgtype.Text        `json:"uploads_playlist_id"`
	FetchStatus       string             `json:"fetch_status"`
	LastFetchedAt     pgtype.Timestamptz `json:"last_fetched_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Enabled           bool               `json:"enabled"`
	IsFavorite        bool               `json:"is_favorite"`
	Priority          int32              `json:"priority"`
	SubscribedAt      pgtype.Timestamptz `json:"subscribed_at"`
}

// ============================================================================
// ListUserEnabledSubscriptions: ユーザーの有効な購読一覧を取得
// ============================================================================
func (q *Queries) ListUserEnabledSubscriptions(ctx context.Context, userID int64) ([]ListUserEnabledSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listUserEnabledSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserEnabledSubscriptionsRow{}
	for rows.Next() {
		var i ListUserEnabledSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.FetchStatus,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Enabled,
			&i.IsFavorite,
			&i.Priority,
			&i.SubscribedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSubscriptions = `-- name: ListUserSubscriptions :many
SELECT 
    s.id,
    s.platform_id,
    s.external_id,
    s.handle,
    s.display_name,
    s.thumbnail_url,
    s.uploads_playlist_id,
    s.fetch_status,
    s.last_fetched_at,
    s.created_at,
    s.updated_at,
    us.enabled,
    us.priority,
    us.created_at as subscribed_at
FROM user_subscriptions us
JOIN sources s ON us.source_id = s.id
WHERE us.user_id = $1
ORDER BY us.priority DESC, us.created_at DESC
`

type ListUserSubscriptionsRow struct {
	ID                pgtype.UUID        `json:"id"`
	PlatformID        string             `json:"platform_id"`
	ExternalID        string             `json:"external_id"`
	Handle            pgtype.Text        `json:"handle"`
	DisplayName       pgtype.Text        `json:"display_name"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	UploadsPlaylistID pgtype.Text        `json:"uploads_playlist_id"`
	FetchStatus       string             `json:"fetch_status"`
	LastFetchedAt     pgtype.Timestamptz `json:"last_fetched_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Enabled           bool               `json:"enabled"`
	Priority          int32              `json:"priority"`
	SubscribedAt      pgtype.Timestamptz `json:"subscribed_at"`
}

// ============================================================================
// ListUserSubscriptions: ユーザーの購読一覧を取得（source情報付き）
// ============================================================================
func (q *Queries) ListUserSubscriptions(ctx context.Context, userID int64) ([]ListUserSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listUserSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSubscriptionsRow{}
	for rows.Next() {
		var i ListUserSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.FetchStatus,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Enabled,
			&i.Priority,
			&i.SubscribedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleSubscriptionFavorite = `-- name: ToggleSubscriptionFavorite :one
UPDATE user_subscriptions
SET is_favorite = $3, updated_at = now()
WHERE user_id = $1 AND source_id = $2
RETURNING user_id, source_id, enabled, priority, created_at, updated_at, is_favorite, last_accessed_at
`

type ToggleSubscriptionFavoriteParams struct {
	UserID     int64       `json:"user_id"`
	SourceID   pgtype.UUID `json:"source_id"`
	IsFavorite bool        `json:"is_favorite"`
}

// ============================================================================
// ToggleSubscriptionFavorite: お気に入り状態を切り替え
// ============================================================================
func (q *Queries) ToggleSubscriptionFavorite(ctx context.Context, arg ToggleSubscriptionFavoriteParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, toggleSubscriptionFavorite, arg.UserID, arg.SourceID, arg.IsFavorite)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.SourceID,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFavorite,
		&i.LastAccessedAt,
	)
	return i, err
}

const updateSubscriptionEnabled = `-- name: UpdateSubscriptionEnabled :one
UPDATE user_subscriptions
SET
    enabled = $3,
    updated_at = now()
WHERE user_id = $1 AND source_id = $2
RETURNING user_id, source_id, enabled, priority, created_at, updated_at, is_favorite, last_accessed_at
`

type UpdateSubscriptionEnabledParams struct {
	UserID   int64       `json:"user_id"`
	SourceID pgtype.UUID `json:"source_id"`
	Enabled  bool        `json:"enabled"`
}

// ============================================================================
// UpdateSubscriptionEnabled: 購読の有効/無効を切り替え
// ============================================================================
func (q *Queries) UpdateSubscriptionEnabled(ctx context.Context, arg UpdateSubscriptionEnabledParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionEnabled, arg.UserID, arg.SourceID, arg.Enabled)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.SourceID,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFavorite,
		&i.LastAccessedAt,
	)
	return i, err
}

const updateSubscriptionPriority = `-- name: UpdateSubscriptionPriority :one
UPDATE user_subscriptions
SET
    priority = $3,
    updated_at = now()
WHERE user_id = $1 AND source_id = $2
RETURNING user_id, source_id, enabled, priority, created_at, updated_at, is_favorite, last_accessed_at
`

type UpdateSubscriptionPriorityParams struct {
	UserID   int64       `json:"user_id"`
	SourceID pgtype.UUID `json:"source_id"`
	Priority int32       `json:"priority"`
}

// ============================================================================
// UpdateSubscriptionPriority: 購読の優先度を更新
// ============================================================================
func (q *Queries) UpdateSubscriptionPriority(ctx context.Context, arg UpdateSubscriptionPriorityParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionPriority, arg.UserID, arg.SourceID, arg.Priority)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.SourceID,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFavorite,
		&i.LastAccessedAt,
	)
	return i, err
}

const upsertUserSubscription = `-- name: UpsertUserSubscription :one

INSERT INTO user_subscriptions (
    user_id,
    source_id,
    enabled,
    priority,
    updated_at
) VALUES (
    $1, $2, $3, $4, now()
)
ON CONFLICT (user_id, source_id)
DO UPDATE SET
    enabled = EXCLUDED.enabled,
    priority = EXCLUDED.priority,
    updated_at = now()
RETURNING user_id, source_id, enabled, priority, created_at, updated_at, is_favorite, last_accessed_at
`

type UpsertUserSubscriptionParams struct {
	UserID   int64       `json:"user_id"`
	SourceID pgtype.UUID `json:"source_id"`
	Enabled  bool        `json:"enabled"`
	Priority int32       `json:"priority"`
}

// query_subscriptions.sql
// User subscriptions（ユーザーの購読情報）に関するクエリ
// ============================================================================
// UpsertUserSubscription: 購読情報のupsert
// ============================================================================
func (q *Queries) UpsertUserSubscription(ctx context.Context, arg UpsertUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, upsertUserSubscription,
		arg.UserID,
		arg.SourceID,
		arg.Enabled,
		arg.Priority,
	)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.SourceID,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFavorite,
		&i.LastAccessedAt,
	)
	return i, err
}
