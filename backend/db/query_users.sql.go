// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInactiveAnonymousUsers = `-- name: DeleteInactiveAnonymousUsers :exec
DELETE FROM users WHERE is_anonymous = true AND last_accessed_at < now() - INTERVAL '30 days'
`

func (q *Queries) DeleteInactiveAnonymousUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteInactiveAnonymousUsers)
	return err
}

const getPlanLimit = `-- name: GetPlanLimit :one
SELECT plan_type, max_channels, display_name, price_monthly, has_favorites, has_device_sync, description, created_at FROM plan_limits WHERE plan_type = $1
`

func (q *Queries) GetPlanLimit(ctx context.Context, planType string) (PlanLimit, error) {
	row := q.db.QueryRow(ctx, getPlanLimit, planType)
	var i PlanLimit
	err := row.Scan(
		&i.PlanType,
		&i.MaxChannels,
		&i.DisplayName,
		&i.PriceMonthly,
		&i.HasFavorites,
		&i.HasDeviceSync,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByFirebaseUID = `-- name: GetUserByFirebaseUID :one
SELECT id, firebase_uid, plan_type, email, display_name, photo_url, is_anonymous, last_accessed_at, created_at, updated_at FROM users WHERE firebase_uid = $1
`

func (q *Queries) GetUserByFirebaseUID(ctx context.Context, firebaseUid string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByFirebaseUID, firebaseUid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirebaseUid,
		&i.PlanType,
		&i.Email,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsAnonymous,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, firebase_uid, plan_type, email, display_name, photo_url, is_anonymous, last_accessed_at, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirebaseUid,
		&i.PlanType,
		&i.Email,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsAnonymous,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserWithPlanInfo = `-- name: GetUserWithPlanInfo :one
SELECT 
    u.id,
    u.firebase_uid,
    u.plan_type,
    u.email,
    u.display_name,
    u.photo_url,
    u.is_anonymous,
    u.last_accessed_at,
    u.created_at,
    u.updated_at,
    pl.max_channels,
    pl.display_name as plan_display_name,
    pl.price_monthly,
    pl.has_favorites,
    pl.has_device_sync,
    pl.description as plan_description
FROM users u
LEFT JOIN plan_limits pl ON u.plan_type = pl.plan_type
WHERE u.id = $1
`

type GetUserWithPlanInfoRow struct {
	ID              int64              `json:"id"`
	FirebaseUid     string             `json:"firebase_uid"`
	PlanType        string             `json:"plan_type"`
	Email           pgtype.Text        `json:"email"`
	DisplayName     pgtype.Text        `json:"display_name"`
	PhotoUrl        pgtype.Text        `json:"photo_url"`
	IsAnonymous     bool               `json:"is_anonymous"`
	LastAccessedAt  pgtype.Timestamptz `json:"last_accessed_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	MaxChannels     pgtype.Int4        `json:"max_channels"`
	PlanDisplayName pgtype.Text        `json:"plan_display_name"`
	PriceMonthly    pgtype.Int4        `json:"price_monthly"`
	HasFavorites    pgtype.Bool        `json:"has_favorites"`
	HasDeviceSync   pgtype.Bool        `json:"has_device_sync"`
	PlanDescription pgtype.Text        `json:"plan_description"`
}

func (q *Queries) GetUserWithPlanInfo(ctx context.Context, id int64) (GetUserWithPlanInfoRow, error) {
	row := q.db.QueryRow(ctx, getUserWithPlanInfo, id)
	var i GetUserWithPlanInfoRow
	err := row.Scan(
		&i.ID,
		&i.FirebaseUid,
		&i.PlanType,
		&i.Email,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsAnonymous,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MaxChannels,
		&i.PlanDisplayName,
		&i.PriceMonthly,
		&i.HasFavorites,
		&i.HasDeviceSync,
		&i.PlanDescription,
	)
	return i, err
}

const listAllPlanLimits = `-- name: ListAllPlanLimits :many
SELECT plan_type, max_channels, display_name, price_monthly, has_favorites, has_device_sync, description, created_at FROM plan_limits ORDER BY price_monthly NULLS FIRST
`

func (q *Queries) ListAllPlanLimits(ctx context.Context) ([]PlanLimit, error) {
	rows, err := q.db.Query(ctx, listAllPlanLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PlanLimit{}
	for rows.Next() {
		var i PlanLimit
		if err := rows.Scan(
			&i.PlanType,
			&i.MaxChannels,
			&i.DisplayName,
			&i.PriceMonthly,
			&i.HasFavorites,
			&i.HasDeviceSync,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserPlan = `-- name: UpdateUserPlan :one
UPDATE users SET plan_type = $2, is_anonymous = false, updated_at = now()
WHERE id = $1 RETURNING id, firebase_uid, plan_type, email, display_name, photo_url, is_anonymous, last_accessed_at, created_at, updated_at
`

type UpdateUserPlanParams struct {
	ID       int64  `json:"id"`
	PlanType string `json:"plan_type"`
}

func (q *Queries) UpdateUserPlan(ctx context.Context, arg UpdateUserPlanParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPlan, arg.ID, arg.PlanType)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirebaseUid,
		&i.PlanType,
		&i.Email,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsAnonymous,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT INTO users (id, firebase_uid, plan_type, email, display_name, photo_url, is_anonymous, last_accessed_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, now(), now())
ON CONFLICT (firebase_uid) DO UPDATE SET
    email = COALESCE(EXCLUDED.email, users.email),
    display_name = COALESCE(EXCLUDED.display_name, users.display_name),
    photo_url = COALESCE(EXCLUDED.photo_url, users.photo_url),
    last_accessed_at = now(),
    updated_at = now()
RETURNING id, firebase_uid, plan_type, email, display_name, photo_url, is_anonymous, last_accessed_at, created_at, updated_at
`

type UpsertUserParams struct {
	ID          int64       `json:"id"`
	FirebaseUid string      `json:"firebase_uid"`
	PlanType    string      `json:"plan_type"`
	Email       pgtype.Text `json:"email"`
	DisplayName pgtype.Text `json:"display_name"`
	PhotoUrl    pgtype.Text `json:"photo_url"`
	IsAnonymous bool        `json:"is_anonymous"`
}

// query_users.sql
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.ID,
		arg.FirebaseUid,
		arg.PlanType,
		arg.Email,
		arg.DisplayName,
		arg.PhotoUrl,
		arg.IsAnonymous,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirebaseUid,
		&i.PlanType,
		&i.Email,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsAnonymous,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
