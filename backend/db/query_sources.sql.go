// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_sources.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSourceByExternalID = `-- name: GetSourceByExternalID :one
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
WHERE platform_id = $1 AND external_id = $2
`

type GetSourceByExternalIDParams struct {
	PlatformID string `json:"platform_id"`
	ExternalID string `json:"external_id"`
}

// ============================================================================
// GetSourceByExternalID: 外部ID（platform + external_id）でソース取得
// ============================================================================
func (q *Queries) GetSourceByExternalID(ctx context.Context, arg GetSourceByExternalIDParams) (Source, error) {
	row := q.db.QueryRow(ctx, getSourceByExternalID, arg.PlatformID, arg.ExternalID)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.ExternalID,
		&i.Handle,
		&i.DisplayName,
		&i.ThumbnailUrl,
		&i.UploadsPlaylistID,
		&i.LastFetchedAt,
		&i.FetchStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplePodcastUrl,
	)
	return i, err
}

const getSourceByID = `-- name: GetSourceByID :one
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
WHERE id = $1
`

// ============================================================================
// GetSourceByID: IDでソース取得
// ============================================================================
func (q *Queries) GetSourceByID(ctx context.Context, id pgtype.UUID) (Source, error) {
	row := q.db.QueryRow(ctx, getSourceByID, id)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.ExternalID,
		&i.Handle,
		&i.DisplayName,
		&i.ThumbnailUrl,
		&i.UploadsPlaylistID,
		&i.LastFetchedAt,
		&i.FetchStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplePodcastUrl,
	)
	return i, err
}

const listSources = `-- name: ListSources :many
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
ORDER BY created_at DESC
LIMIT $1
`

// ============================================================================
// ListSources: ソース一覧を取得
// ============================================================================
func (q *Queries) ListSources(ctx context.Context, limit int32) ([]Source, error) {
	rows, err := q.db.Query(ctx, listSources, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesByPlatform = `-- name: ListSourcesByPlatform :many
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
WHERE platform_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListSourcesByPlatformParams struct {
	PlatformID string `json:"platform_id"`
	Limit      int32  `json:"limit"`
}

// ============================================================================
// ListSourcesByPlatform: プラットフォーム別にソース一覧を取得
// ============================================================================
func (q *Queries) ListSourcesByPlatform(ctx context.Context, arg ListSourcesByPlatformParams) ([]Source, error) {
	rows, err := q.db.Query(ctx, listSourcesByPlatform, arg.PlatformID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesForFetch = `-- name: ListSourcesForFetch :many
SELECT s.id, s.platform_id, s.external_id, s.handle, s.display_name, s.thumbnail_url, s.uploads_playlist_id, s.last_fetched_at, s.fetch_status, s.created_at, s.updated_at, s.apple_podcast_url
FROM sources s
WHERE 
    s.fetch_status = 'ok'
    AND (
        s.last_fetched_at IS NULL 
        OR s.last_fetched_at < now() - INTERVAL '10 minutes'
    )
ORDER BY s.last_fetched_at ASC NULLS FIRST
LIMIT $1
`

// ============================================================================
// ListSourcesForFetch: 取り込み対象のソースを取得
// ============================================================================
func (q *Queries) ListSourcesForFetch(ctx context.Context, limit int32) ([]Source, error) {
	rows, err := q.db.Query(ctx, listSourcesForFetch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popularSources = `-- name: PopularSources :many
SELECT s.id, s.platform_id, s.external_id, s.handle, s.display_name, s.thumbnail_url, s.uploads_playlist_id, s.last_fetched_at, s.fetch_status, s.created_at, s.updated_at, s.apple_podcast_url, COUNT(us.user_id) as subscriber_count
FROM sources s
JOIN user_subscriptions us ON s.id = us.source_id
WHERE us.enabled = true
GROUP BY s.id
ORDER BY subscriber_count DESC
LIMIT $1
`

type PopularSourcesRow struct {
	ID                pgtype.UUID        `json:"id"`
	PlatformID        string             `json:"platform_id"`
	ExternalID        string             `json:"external_id"`
	Handle            pgtype.Text        `json:"handle"`
	DisplayName       pgtype.Text        `json:"display_name"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	UploadsPlaylistID pgtype.Text        `json:"uploads_playlist_id"`
	LastFetchedAt     pgtype.Timestamptz `json:"last_fetched_at"`
	FetchStatus       string             `json:"fetch_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ApplePodcastUrl   pgtype.Text        `json:"apple_podcast_url"`
	SubscriberCount   int64              `json:"subscriber_count"`
}

// ============================================================================
// PopularSources: Pixicast内の人気チャンネル（購読者数順）
// ============================================================================
func (q *Queries) PopularSources(ctx context.Context, maxResults int32) ([]PopularSourcesRow, error) {
	rows, err := q.db.Query(ctx, popularSources, maxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PopularSourcesRow{}
	for rows.Next() {
		var i PopularSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
			&i.SubscriberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSources = `-- name: SearchSources :many
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
WHERE
    (display_name ILIKE '%' || $1::TEXT || '%')
    OR (handle ILIKE '%' || $1::TEXT || '%')
ORDER BY display_name ASC
LIMIT $2
`

type SearchSourcesParams struct {
	Query      string `json:"query"`
	MaxResults int32  `json:"max_results"`
}

// ============================================================================
// SearchSources: キーワードでソースを検索（全プラットフォーム）
// ============================================================================
func (q *Queries) SearchSources(ctx context.Context, arg SearchSourcesParams) ([]Source, error) {
	rows, err := q.db.Query(ctx, searchSources, arg.Query, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSourcesByPlatform = `-- name: SearchSourcesByPlatform :many
SELECT id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url FROM sources
WHERE
    platform_id = $1
    AND (
        (display_name ILIKE '%' || $2::TEXT || '%')
        OR (handle ILIKE '%' || $2::TEXT || '%')
    )
ORDER BY display_name ASC
LIMIT $3
`

type SearchSourcesByPlatformParams struct {
	PlatformID string `json:"platform_id"`
	Query      string `json:"query"`
	MaxResults int32  `json:"max_results"`
}

// ============================================================================
// SearchSourcesByPlatform: プラットフォーム指定でキーワード検索
// ============================================================================
func (q *Queries) SearchSourcesByPlatform(ctx context.Context, arg SearchSourcesByPlatformParams) ([]Source, error) {
	rows, err := q.db.Query(ctx, searchSourcesByPlatform, arg.PlatformID, arg.Query, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.ExternalID,
			&i.Handle,
			&i.DisplayName,
			&i.ThumbnailUrl,
			&i.UploadsPlaylistID,
			&i.LastFetchedAt,
			&i.FetchStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ApplePodcastUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSourceFetchStatus = `-- name: UpdateSourceFetchStatus :one
UPDATE sources
SET
    fetch_status = $2,
    last_fetched_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url
`

type UpdateSourceFetchStatusParams struct {
	ID          pgtype.UUID `json:"id"`
	FetchStatus string      `json:"fetch_status"`
}

// ============================================================================
// UpdateSourceFetchStatus: 取り込みステータスを更新
// ============================================================================
func (q *Queries) UpdateSourceFetchStatus(ctx context.Context, arg UpdateSourceFetchStatusParams) (Source, error) {
	row := q.db.QueryRow(ctx, updateSourceFetchStatus, arg.ID, arg.FetchStatus)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.ExternalID,
		&i.Handle,
		&i.DisplayName,
		&i.ThumbnailUrl,
		&i.UploadsPlaylistID,
		&i.LastFetchedAt,
		&i.FetchStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplePodcastUrl,
	)
	return i, err
}

const upsertSource = `-- name: UpsertSource :one

INSERT INTO sources (
    platform_id,
    external_id,
    handle,
    display_name,
    thumbnail_url,
    uploads_playlist_id,
    apple_podcast_url,
    fetch_status,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, 'ok', now()
)
ON CONFLICT (platform_id, external_id)
DO UPDATE SET
    handle = EXCLUDED.handle,
    display_name = EXCLUDED.display_name,
    thumbnail_url = EXCLUDED.thumbnail_url,
    uploads_playlist_id = EXCLUDED.uploads_playlist_id,
    apple_podcast_url = EXCLUDED.apple_podcast_url,
    fetch_status = EXCLUDED.fetch_status,
    updated_at = now()
RETURNING id, platform_id, external_id, handle, display_name, thumbnail_url, uploads_playlist_id, last_fetched_at, fetch_status, created_at, updated_at, apple_podcast_url
`

type UpsertSourceParams struct {
	PlatformID        string      `json:"platform_id"`
	ExternalID        string      `json:"external_id"`
	Handle            pgtype.Text `json:"handle"`
	DisplayName       pgtype.Text `json:"display_name"`
	ThumbnailUrl      pgtype.Text `json:"thumbnail_url"`
	UploadsPlaylistID pgtype.Text `json:"uploads_playlist_id"`
	ApplePodcastUrl   pgtype.Text `json:"apple_podcast_url"`
}

// query_sources.sql
// Sources（チャンネル/配信者）に関するクエリ
// ============================================================================
// UpsertSource: チャンネル情報のupsert
// ============================================================================
func (q *Queries) UpsertSource(ctx context.Context, arg UpsertSourceParams) (Source, error) {
	row := q.db.QueryRow(ctx, upsertSource,
		arg.PlatformID,
		arg.ExternalID,
		arg.Handle,
		arg.DisplayName,
		arg.ThumbnailUrl,
		arg.UploadsPlaylistID,
		arg.ApplePodcastUrl,
	)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.ExternalID,
		&i.Handle,
		&i.DisplayName,
		&i.ThumbnailUrl,
		&i.UploadsPlaylistID,
		&i.LastFetchedAt,
		&i.FetchStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ApplePodcastUrl,
	)
	return i, err
}
