// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_timeline.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventsBySource = `-- name: CountEventsBySource :one
SELECT COUNT(*) FROM events
WHERE source_id = $1
`

// ============================================================================
// CountEventsBySource: ソース別のイベント数をカウント
// ============================================================================
func (q *Queries) CountEventsBySource(ctx context.Context, sourceID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsBySource, sourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldEvents = `-- name: DeleteOldEvents :exec
DELETE FROM events
WHERE 
    type = 'video'
    AND published_at < now() - INTERVAL '90 days'
`

// ============================================================================
// DeleteOldEvents: 古いイベントを削除（アーカイブ）
// ============================================================================
func (q *Queries) DeleteOldEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldEvents)
	return err
}

const getEventByExternalID = `-- name: GetEventByExternalID :one
SELECT id, platform_id, source_id, external_event_id, type, title, description, start_at, end_at, published_at, url, image_url, metrics, created_at, updated_at, duration FROM events
WHERE platform_id = $1 AND external_event_id = $2
`

type GetEventByExternalIDParams struct {
	PlatformID      string `json:"platform_id"`
	ExternalEventID string `json:"external_event_id"`
}

// ============================================================================
// GetEventByExternalID: 外部IDでイベント取得
// ============================================================================
func (q *Queries) GetEventByExternalID(ctx context.Context, arg GetEventByExternalIDParams) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByExternalID, arg.PlatformID, arg.ExternalEventID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.SourceID,
		&i.ExternalEventID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.StartAt,
		&i.EndAt,
		&i.PublishedAt,
		&i.Url,
		&i.ImageUrl,
		&i.Metrics,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
	)
	return i, err
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, platform_id, source_id, external_event_id, type, title, description, start_at, end_at, published_at, url, image_url, metrics, created_at, updated_at, duration FROM events
WHERE id = $1
`

// ============================================================================
// GetEventByID: IDでイベント取得
// ============================================================================
func (q *Queries) GetEventByID(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.SourceID,
		&i.ExternalEventID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.StartAt,
		&i.EndAt,
		&i.PublishedAt,
		&i.Url,
		&i.ImageUrl,
		&i.Metrics,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
	)
	return i, err
}

const listEventsByType = `-- name: ListEventsByType :many
SELECT 
    e.id,
    e.platform_id,
    e.source_id,
    e.external_event_id,
    e.type,
    e.title,
    e.description,
    e.start_at,
    e.end_at,
    e.published_at,
    e.url,
    e.image_url,
    e.metrics,
    e.created_at,
    e.updated_at,
    s.display_name as source_display_name,
    s.thumbnail_url as source_thumbnail_url,
    s.handle as source_handle
FROM events e
JOIN sources s ON e.source_id = s.id
JOIN user_subscriptions us ON s.id = us.source_id
WHERE 
    us.user_id = $1
    AND us.enabled = true
    AND e.type = $2
ORDER BY COALESCE(e.start_at, e.published_at) DESC NULLS LAST
LIMIT $3
`

type ListEventsByTypeParams struct {
	UserID int64  `json:"user_id"`
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
}

type ListEventsByTypeRow struct {
	ID                 pgtype.UUID        `json:"id"`
	PlatformID         string             `json:"platform_id"`
	SourceID           pgtype.UUID        `json:"source_id"`
	ExternalEventID    string             `json:"external_event_id"`
	Type               string             `json:"type"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	StartAt            pgtype.Timestamptz `json:"start_at"`
	EndAt              pgtype.Timestamptz `json:"end_at"`
	PublishedAt        pgtype.Timestamptz `json:"published_at"`
	Url                string             `json:"url"`
	ImageUrl           pgtype.Text        `json:"image_url"`
	Metrics            []byte             `json:"metrics"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	SourceDisplayName  pgtype.Text        `json:"source_display_name"`
	SourceThumbnailUrl pgtype.Text        `json:"source_thumbnail_url"`
	SourceHandle       pgtype.Text        `json:"source_handle"`
}

// ============================================================================
// ListEventsByType: タイプ別にイベントを取得
// ============================================================================
func (q *Queries) ListEventsByType(ctx context.Context, arg ListEventsByTypeParams) ([]ListEventsByTypeRow, error) {
	rows, err := q.db.Query(ctx, listEventsByType, arg.UserID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByTypeRow{}
	for rows.Next() {
		var i ListEventsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.SourceID,
			&i.ExternalEventID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.StartAt,
			&i.EndAt,
			&i.PublishedAt,
			&i.Url,
			&i.ImageUrl,
			&i.Metrics,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceDisplayName,
			&i.SourceThumbnailUrl,
			&i.SourceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiveEvents = `-- name: ListLiveEvents :many
SELECT 
    e.id,
    e.platform_id,
    e.source_id,
    e.external_event_id,
    e.type,
    e.title,
    e.description,
    e.start_at,
    e.end_at,
    e.published_at,
    e.url,
    e.image_url,
    e.metrics,
    e.created_at,
    e.updated_at,
    s.display_name as source_display_name,
    s.thumbnail_url as source_thumbnail_url,
    s.handle as source_handle
FROM events e
JOIN sources s ON e.source_id = s.id
JOIN user_subscriptions us ON s.id = us.source_id
WHERE 
    us.user_id = $1
    AND us.enabled = true
    AND e.type = 'live'
    AND e.start_at IS NOT NULL
    AND e.start_at <= now()
    AND (e.end_at IS NULL OR e.end_at > now())
ORDER BY e.start_at DESC
LIMIT $2
`

type ListLiveEventsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type ListLiveEventsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	PlatformID         string             `json:"platform_id"`
	SourceID           pgtype.UUID        `json:"source_id"`
	ExternalEventID    string             `json:"external_event_id"`
	Type               string             `json:"type"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	StartAt            pgtype.Timestamptz `json:"start_at"`
	EndAt              pgtype.Timestamptz `json:"end_at"`
	PublishedAt        pgtype.Timestamptz `json:"published_at"`
	Url                string             `json:"url"`
	ImageUrl           pgtype.Text        `json:"image_url"`
	Metrics            []byte             `json:"metrics"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	SourceDisplayName  pgtype.Text        `json:"source_display_name"`
	SourceThumbnailUrl pgtype.Text        `json:"source_thumbnail_url"`
	SourceHandle       pgtype.Text        `json:"source_handle"`
}

// ============================================================================
// ListLiveEvents: 配信中のイベントを取得
// ============================================================================
func (q *Queries) ListLiveEvents(ctx context.Context, arg ListLiveEventsParams) ([]ListLiveEventsRow, error) {
	rows, err := q.db.Query(ctx, listLiveEvents, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLiveEventsRow{}
	for rows.Next() {
		var i ListLiveEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.SourceID,
			&i.ExternalEventID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.StartAt,
			&i.EndAt,
			&i.PublishedAt,
			&i.Url,
			&i.ImageUrl,
			&i.Metrics,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceDisplayName,
			&i.SourceThumbnailUrl,
			&i.SourceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeline = `-- name: ListTimeline :many
SELECT 
    e.id,
    e.platform_id,
    e.source_id,
    e.external_event_id,
    e.type,
    e.title,
    e.description,
    e.start_at,
    e.end_at,
    e.published_at,
    e.url,
    e.image_url,
    e.metrics,
    e.duration,
    e.created_at,
    e.updated_at,
    s.display_name as source_display_name,
    s.thumbnail_url as source_thumbnail_url,
    s.handle as source_handle,
    s.external_id as source_external_id
FROM events e
JOIN sources s ON e.source_id = s.id
JOIN user_subscriptions us ON s.id = us.source_id
WHERE 
    us.user_id = $1
    AND us.enabled = true
    AND (
        $2::timestamptz IS NULL
        OR COALESCE(e.start_at, e.published_at) < $2
    )
    AND (
        $4::text[] IS NULL
        OR s.external_id = ANY($4::text[])
    )
ORDER BY 
    COALESCE(e.start_at, e.published_at) DESC NULLS LAST,
    CASE WHEN e.type = 'live' THEN 0 ELSE 1 END ASC
LIMIT $3
`

type ListTimelineParams struct {
	UserID     int64              `json:"user_id"`
	Column2    pgtype.Timestamptz `json:"column_2"`
	Limit      int32              `json:"limit"`
	ChannelIds []string           `json:"channel_ids"`
}

type ListTimelineRow struct {
	ID                 pgtype.UUID        `json:"id"`
	PlatformID         string             `json:"platform_id"`
	SourceID           pgtype.UUID        `json:"source_id"`
	ExternalEventID    string             `json:"external_event_id"`
	Type               string             `json:"type"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	StartAt            pgtype.Timestamptz `json:"start_at"`
	EndAt              pgtype.Timestamptz `json:"end_at"`
	PublishedAt        pgtype.Timestamptz `json:"published_at"`
	Url                string             `json:"url"`
	ImageUrl           pgtype.Text        `json:"image_url"`
	Metrics            []byte             `json:"metrics"`
	Duration           pgtype.Text        `json:"duration"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	SourceDisplayName  pgtype.Text        `json:"source_display_name"`
	SourceThumbnailUrl pgtype.Text        `json:"source_thumbnail_url"`
	SourceHandle       pgtype.Text        `json:"source_handle"`
	SourceExternalID   string             `json:"source_external_id"`
}

// ============================================================================
// ListTimeline: ユーザーのタイムラインを取得
// ============================================================================
func (q *Queries) ListTimeline(ctx context.Context, arg ListTimelineParams) ([]ListTimelineRow, error) {
	rows, err := q.db.Query(ctx, listTimeline,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.ChannelIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTimelineRow{}
	for rows.Next() {
		var i ListTimelineRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.SourceID,
			&i.ExternalEventID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.StartAt,
			&i.EndAt,
			&i.PublishedAt,
			&i.Url,
			&i.ImageUrl,
			&i.Metrics,
			&i.Duration,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceDisplayName,
			&i.SourceThumbnailUrl,
			&i.SourceHandle,
			&i.SourceExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimelineBySource = `-- name: ListTimelineBySource :many
SELECT id, platform_id, source_id, external_event_id, type, title, description, start_at, end_at, published_at, url, image_url, metrics, created_at, updated_at, duration FROM events
WHERE source_id = $1
ORDER BY COALESCE(start_at, published_at) DESC NULLS LAST
LIMIT $2
`

type ListTimelineBySourceParams struct {
	SourceID pgtype.UUID `json:"source_id"`
	Limit    int32       `json:"limit"`
}

// ============================================================================
// ListTimelineBySource: 特定ソースのタイムラインを取得
// ============================================================================
func (q *Queries) ListTimelineBySource(ctx context.Context, arg ListTimelineBySourceParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listTimelineBySource, arg.SourceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.SourceID,
			&i.ExternalEventID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.StartAt,
			&i.EndAt,
			&i.PublishedAt,
			&i.Url,
			&i.ImageUrl,
			&i.Metrics,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingEvents = `-- name: ListUpcomingEvents :many
SELECT 
    e.id,
    e.platform_id,
    e.source_id,
    e.external_event_id,
    e.type,
    e.title,
    e.description,
    e.start_at,
    e.end_at,
    e.published_at,
    e.url,
    e.image_url,
    e.metrics,
    e.created_at,
    e.updated_at,
    s.display_name as source_display_name,
    s.thumbnail_url as source_thumbnail_url,
    s.handle as source_handle
FROM events e
JOIN sources s ON e.source_id = s.id
JOIN user_subscriptions us ON s.id = us.source_id
WHERE 
    us.user_id = $1
    AND us.enabled = true
    AND e.type IN ('scheduled', 'premiere')
    AND e.start_at IS NOT NULL
    AND e.start_at > now()
ORDER BY e.start_at ASC
LIMIT $2
`

type ListUpcomingEventsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type ListUpcomingEventsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	PlatformID         string             `json:"platform_id"`
	SourceID           pgtype.UUID        `json:"source_id"`
	ExternalEventID    string             `json:"external_event_id"`
	Type               string             `json:"type"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	StartAt            pgtype.Timestamptz `json:"start_at"`
	EndAt              pgtype.Timestamptz `json:"end_at"`
	PublishedAt        pgtype.Timestamptz `json:"published_at"`
	Url                string             `json:"url"`
	ImageUrl           pgtype.Text        `json:"image_url"`
	Metrics            []byte             `json:"metrics"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	SourceDisplayName  pgtype.Text        `json:"source_display_name"`
	SourceThumbnailUrl pgtype.Text        `json:"source_thumbnail_url"`
	SourceHandle       pgtype.Text        `json:"source_handle"`
}

// ============================================================================
// ListUpcomingEvents: 今後予定されているイベントを取得
// ============================================================================
func (q *Queries) ListUpcomingEvents(ctx context.Context, arg ListUpcomingEventsParams) ([]ListUpcomingEventsRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingEvents, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingEventsRow{}
	for rows.Next() {
		var i ListUpcomingEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlatformID,
			&i.SourceID,
			&i.ExternalEventID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.StartAt,
			&i.EndAt,
			&i.PublishedAt,
			&i.Url,
			&i.ImageUrl,
			&i.Metrics,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceDisplayName,
			&i.SourceThumbnailUrl,
			&i.SourceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEvent = `-- name: UpsertEvent :one

INSERT INTO events (
    platform_id,
    source_id,
    external_event_id,
    type,
    title,
    description,
    start_at,
    end_at,
    published_at,
    url,
    image_url,
    metrics,
    duration,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, now()
)
ON CONFLICT (platform_id, external_event_id)
DO UPDATE SET
    type = EXCLUDED.type,
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    start_at = EXCLUDED.start_at,
    end_at = EXCLUDED.end_at,
    published_at = EXCLUDED.published_at,
    url = EXCLUDED.url,
    image_url = EXCLUDED.image_url,
    metrics = EXCLUDED.metrics,
    duration = EXCLUDED.duration,
    updated_at = now()
RETURNING id, platform_id, source_id, external_event_id, type, title, description, start_at, end_at, published_at, url, image_url, metrics, created_at, updated_at, duration
`

type UpsertEventParams struct {
	PlatformID      string             `json:"platform_id"`
	SourceID        pgtype.UUID        `json:"source_id"`
	ExternalEventID string             `json:"external_event_id"`
	Type            string             `json:"type"`
	Title           string             `json:"title"`
	Description     pgtype.Text        `json:"description"`
	StartAt         pgtype.Timestamptz `json:"start_at"`
	EndAt           pgtype.Timestamptz `json:"end_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	Url             string             `json:"url"`
	ImageUrl        pgtype.Text        `json:"image_url"`
	Metrics         []byte             `json:"metrics"`
	Duration        pgtype.Text        `json:"duration"`
}

// query_timeline.sql
// Timeline events（タイムライン項目）に関するクエリ
// ============================================================================
// UpsertEvent: イベント情報のupsert
// ============================================================================
func (q *Queries) UpsertEvent(ctx context.Context, arg UpsertEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, upsertEvent,
		arg.PlatformID,
		arg.SourceID,
		arg.ExternalEventID,
		arg.Type,
		arg.Title,
		arg.Description,
		arg.StartAt,
		arg.EndAt,
		arg.PublishedAt,
		arg.Url,
		arg.ImageUrl,
		arg.Metrics,
		arg.Duration,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.PlatformID,
		&i.SourceID,
		&i.ExternalEventID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.StartAt,
		&i.EndAt,
		&i.PublishedAt,
		&i.Url,
		&i.ImageUrl,
		&i.Metrics,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
	)
	return i, err
}
