package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strconv"
	"time"

	"connectrpc.com/connect"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	// ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
	"github.com/kinchoKayaba/pixicast/backend/db" // â˜…sqlcãŒä½œã£ãŸã‚³ãƒ¼ãƒ‰
	pixicastv1 "github.com/kinchoKayaba/pixicast/backend/gen/pixicast/v1"
	"github.com/kinchoKayaba/pixicast/backend/gen/pixicast/v1/pixicastv1connect"
	"github.com/kinchoKayaba/pixicast/backend/internal/http/handlers"
	"github.com/kinchoKayaba/pixicast/backend/internal/youtube"
	ytapi "google.golang.org/api/youtube/v3"
)

// ã‚µãƒ¼ãƒãƒ¼æ§‹é€ ä½“
// ç”Ÿã®DBæ¥ç¶šã§ã¯ãªãã€sqlcãŒç”Ÿæˆã—ãŸã€ŒQueriesã€ã‚’æŒã¡ã¾ã™
type TimelineServer struct {
	queries *db.Queries
	youtube *youtube.Client
}

// parseDuration ã¯ ISO 8601 duration (PT1H30M15S) ã‚’ "01:30:15" å½¢å¼ã«å¤‰æ›
func parseDuration(isoDuration string) string {
	if isoDuration == "" {
		return "00:00"
	}

	re := regexp.MustCompile(`PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?`)
	matches := re.FindStringSubmatch(isoDuration)
	if matches == nil {
		return "00:00"
	}

	hours, _ := strconv.Atoi(matches[1])
	minutes, _ := strconv.Atoi(matches[2])
	seconds, _ := strconv.Atoi(matches[3])

	if hours > 0 {
		return fmt.Sprintf("%02d:%02d:%02d", hours, minutes, seconds)
	}
	return fmt.Sprintf("%02d:%02d", minutes, seconds)
}

// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å–å¾—
func (s *TimelineServer) GetTimeline(
	ctx context.Context,
	req *connect.Request[pixicastv1.GetTimelineRequest],
) (*connect.Response[pixicastv1.GetTimelineResponse], error) {
	log.Printf("GetTimeline called for date: %s, youtube_channel_ids: %v", req.Msg.Date, req.Msg.YoutubeChannelIds)

	// 1. DBã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— (SQLå®Ÿè¡Œ) - æ–°ã‚¹ã‚­ãƒ¼ãƒã®ListTimelineã‚’ä½¿ç”¨
	// TODO: èªè¨¼å®Ÿè£…å¾Œã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰user_idã‚’å–å¾—
	timelineData, err := s.queries.ListTimeline(ctx, db.ListTimelineParams{
		UserID:  1, // æš«å®š: user_id=1 å›ºå®š
		Column2: pgtype.Timestamptz{Valid: false}, // before_time ãªã—
		Limit:   100,
	})
	if err != nil {
		log.Printf("Failed to fetch timeline: %v", err)
		return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("database error"))
	}
	log.Printf("ğŸ“Š DB timeline events fetched: %d", len(timelineData))

	// 2. DBã®å‹(db.ListTimelineRow) ã‚’ gRPCã®å‹(pixicastv1.Program) ã«å¤‰æ›
	var responsePrograms []*pixicastv1.Program
	for _, event := range timelineData {
		// æ”¾é€ä¸­ã‹ã©ã†ã‹ã®ç°¡æ˜“åˆ¤å®š
		now := time.Now()
		isLive := event.Type == "live" && 
			event.StartAt.Valid && 
			now.After(event.StartAt.Time) &&
			(!event.EndAt.Valid || now.Before(event.EndAt.Time))

		// NULLè¨±å®¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‡¦ç†
		imageUrl := ""
		if event.ImageUrl.Valid {
			imageUrl = event.ImageUrl.String
		}
		description := ""
		if event.Description.Valid {
			description = event.Description.String
		}
		channelTitle := ""
		if event.SourceDisplayName.Valid {
			channelTitle = event.SourceDisplayName.String
		}
		channelThumbnailUrl := ""
		if event.SourceThumbnailUrl.Valid {
			channelThumbnailUrl = event.SourceThumbnailUrl.String
		}

		// start_at ã¾ãŸã¯ published_at ã‚’ä½¿ç”¨
		startAt := ""
		publishedAt := ""
		if event.StartAt.Valid {
			startAt = event.StartAt.Time.Format(time.RFC3339)
		} else if event.PublishedAt.Valid {
			startAt = event.PublishedAt.Time.Format(time.RFC3339)
			publishedAt = event.PublishedAt.Time.Format(time.RFC3339)
		}

		endAt := ""
		if event.EndAt.Valid {
			endAt = event.EndAt.Time.Format(time.RFC3339)
		} else if event.PublishedAt.Valid {
			endAt = event.PublishedAt.Time.Format(time.RFC3339)
		}

		// metricsã‹ã‚‰å†ç”Ÿå›æ•°ã‚’å–å¾—
		viewCount := int64(0)
		// TODO: metricsã‹ã‚‰JSONã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦å†ç”Ÿå›æ•°ã‚’å–å¾—

		responsePrograms = append(responsePrograms, &pixicastv1.Program{
			Id:                  event.ID.String(),
			Title:               event.Title,
			StartAt:             startAt,
			EndAt:               endAt,
			PlatformName:        event.PlatformID,
			ImageUrl:            imageUrl,
			LinkUrl:             event.Url,
			IsLive:              isLive,
			ChannelTitle:        channelTitle,
			Description:         description,
			Duration:            "", // TODO: durationã‚’DBã«ä¿å­˜ã—ã¦å–å¾—
			PublishedAt:         publishedAt,
			ViewCount:           viewCount,
			ChannelThumbnailUrl: channelThumbnailUrl,
		})
	}

	// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ï¼ˆDBã‚¯ã‚¨ãƒªã§æ—¢ã«ã‚½ãƒ¼ãƒˆæ¸ˆã¿ï¼‰
	return connect.NewResponse(&pixicastv1.GetTimelineResponse{
		Programs: responsePrograms,
	}), nil
}

// YouTubeãƒ©ã‚¤ãƒ–é…ä¿¡æ¤œç´¢
func (s *TimelineServer) SearchYouTubeLive(
	ctx context.Context,
	req *connect.Request[pixicastv1.SearchYouTubeLiveRequest],
) (*connect.Response[pixicastv1.SearchYouTubeLiveResponse], error) {
	log.Printf("SearchYouTubeLive called with query: %s, max_results: %d", req.Msg.Query, req.Msg.MaxResults)

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š
	maxResults := int64(req.Msg.MaxResults)
	if maxResults <= 0 {
		maxResults = 10
	}
	if maxResults > 50 {
		maxResults = 50
	}

	// YouTube APIã§ãƒ©ã‚¤ãƒ–é…ä¿¡ã‚’æ¤œç´¢
	streams, err := s.youtube.SearchLiveStreams(ctx, req.Msg.Query, maxResults)
	if err != nil {
		log.Printf("Failed to search YouTube live streams: %v", err)
		return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("YouTube API error"))
	}

	// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å¤‰æ›
	var responseStreams []*pixicastv1.YouTubeLiveStream
	for _, stream := range streams {
		thumbnailUrl := ""
		if stream.Snippet.Thumbnails != nil && stream.Snippet.Thumbnails.High != nil {
			thumbnailUrl = stream.Snippet.Thumbnails.High.Url
		}

		responseStreams = append(responseStreams, &pixicastv1.YouTubeLiveStream{
			VideoId:      stream.Id.VideoId,
			Title:        stream.Snippet.Title,
			ChannelTitle: stream.Snippet.ChannelTitle,
			Description:  stream.Snippet.Description,
			ThumbnailUrl: thumbnailUrl,
			PublishedAt:  stream.Snippet.PublishedAt,
		})
	}

	return connect.NewResponse(&pixicastv1.SearchYouTubeLiveResponse{
		Streams: responseStreams,
	}), nil
}
		
		videos, err := s.youtube.GetChannelVideos(ctx, channelID, 20)
		if err != nil {
			log.Printf("Failed to get YouTube videos for channel %s: %v", channelID, err)
			continue // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ä»–ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¯ç¶šè¡Œ
		}
		log.Printf("ğŸ“º YouTube videos fetched from channel %s: %d", channelID, len(videos))

		// å‹•ç”»IDã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
		var videoIDs []string
		for _, video := range videos {
			if video.Id != nil && video.Id.VideoId != "" {
				videoIDs = append(videoIDs, video.Id.VideoId)
			}
		}

		// å‹•ç”»ã®è©³ç´°æƒ…å ±ï¼ˆdurationã‚’å«ã‚€ï¼‰ã‚’ãƒãƒƒãƒã§å–å¾—
		videoDetails, err := s.youtube.GetVideosDetails(ctx, videoIDs)
		if err != nil {
			log.Printf("Failed to get video details for channel %s: %v", channelID, err)
			continue
		}

		// å‹•ç”»IDã‚’ã‚­ãƒ¼ã¨ã—ãŸãƒãƒƒãƒ—ã‚’ä½œæˆ
		detailsMap := make(map[string]*ytapi.Video)
		for _, detail := range videoDetails {
			detailsMap[detail.Id] = detail
		}

		for _, video := range videos {
			thumbnailUrl := ""
			if video.Snippet.Thumbnails != nil && video.Snippet.Thumbnails.High != nil {
				thumbnailUrl = video.Snippet.Thumbnails.High.Url
			}

			// published_atã‚’ãƒ‘ãƒ¼ã‚¹
			publishedAt, err := time.Parse(time.RFC3339, video.Snippet.PublishedAt)
			if err != nil {
				log.Printf("Failed to parse published_at: %v", err)
				publishedAt = time.Now()
			}

		// å‹•ç”»ã®é•·ã•ã¨å†ç”Ÿå›æ•°ã‚’å–å¾—
		duration := ""
		viewCount := int64(0)
		if detail, ok := detailsMap[video.Id.VideoId]; ok {
			if detail.ContentDetails != nil {
				duration = parseDuration(detail.ContentDetails.Duration)
			}
			if detail.Statistics != nil {
				viewCount = int64(detail.Statistics.ViewCount)
			}
		}

		responsePrograms = append(responsePrograms, &pixicastv1.Program{
			Id:                  video.Id.VideoId,
			Title:               video.Snippet.Title,
			StartAt:             publishedAt.Format(time.RFC3339),
			EndAt:               publishedAt.Format(time.RFC3339), // YouTubeã¯åŒã˜å€¤
			PlatformName:        "YouTube",
			ImageUrl:            thumbnailUrl,
			LinkUrl:             fmt.Sprintf("https://www.youtube.com/watch?v=%s", video.Id.VideoId),
			IsLive:              video.Snippet.LiveBroadcastContent == "live",
			ChannelTitle:        video.Snippet.ChannelTitle,
			Description:         video.Snippet.Description,
			Duration:            duration,
			PublishedAt:         publishedAt.Format(time.RFC3339),
			ViewCount:           viewCount,
			ChannelThumbnailUrl: channelThumbnailUrl,
		})
		}
	}

	// 4. å…¨ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ™‚ç³»åˆ—é †ï¼ˆæ–°ã—ã„é †ï¼‰ã«ã‚½ãƒ¼ãƒˆ
	sort.Slice(responsePrograms, func(i, j int) bool {
		timeI, errI := time.Parse(time.RFC3339, responsePrograms[i].StartAt)
		timeJ, errJ := time.Parse(time.RFC3339, responsePrograms[j].StartAt)
		if errI != nil || errJ != nil {
			return false
		}
		// é™é †ï¼ˆæ–°ã—ã„é †ï¼‰
		return timeI.After(timeJ)
	})

	return connect.NewResponse(&pixicastv1.GetTimelineResponse{
		Programs: responsePrograms,
	}), nil
}

// YouTubeãƒ©ã‚¤ãƒ–é…ä¿¡æ¤œç´¢
func (s *TimelineServer) SearchYouTubeLive(
	ctx context.Context,
	req *connect.Request[pixicastv1.SearchYouTubeLiveRequest],
) (*connect.Response[pixicastv1.SearchYouTubeLiveResponse], error) {
	log.Printf("SearchYouTubeLive called with query: %s, max_results: %d", req.Msg.Query, req.Msg.MaxResults)

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š
	maxResults := int64(req.Msg.MaxResults)
	if maxResults <= 0 {
		maxResults = 10
	}
	if maxResults > 50 {
		maxResults = 50
	}

	// YouTube APIã§ãƒ©ã‚¤ãƒ–é…ä¿¡ã‚’æ¤œç´¢
	streams, err := s.youtube.SearchLiveStreams(ctx, req.Msg.Query, maxResults)
	if err != nil {
		log.Printf("Failed to search YouTube live streams: %v", err)
		return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("YouTube API error"))
	}

	// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å¤‰æ›
	var responseStreams []*pixicastv1.YouTubeLiveStream
	for _, stream := range streams {
		thumbnailUrl := ""
		if stream.Snippet.Thumbnails != nil && stream.Snippet.Thumbnails.High != nil {
			thumbnailUrl = stream.Snippet.Thumbnails.High.Url
		}

		responseStreams = append(responseStreams, &pixicastv1.YouTubeLiveStream{
			VideoId:      stream.Id.VideoId,
			Title:        stream.Snippet.Title,
			ChannelTitle: stream.Snippet.ChannelTitle,
			Description:  stream.Snippet.Description,
			ThumbnailUrl: thumbnailUrl,
			PublishedAt:  stream.Snippet.PublishedAt,
		})
	}

	return connect.NewResponse(&pixicastv1.SearchYouTubeLiveResponse{
		Streams: responseStreams,
	}), nil
}

func main() {
	// ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨ï¼‰
	// Cloud Runãªã©ã®æœ¬ç•ªç’°å¢ƒã§ã¯ç’°å¢ƒå¤‰æ•°ã‚’ç›´æ¥è¨­å®šã™ã‚‹ã®ã§ã€.envãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¸è¦
	// GO_ENV ãŒ production ãªã‚‰ .env.productionã€ãã‚Œä»¥å¤–ã¯ .env.dev ã‚’è©¦ã¿ã‚‹
	envFile := ".env.dev"
	if os.Getenv("GO_ENV") == "production" {
		envFile = ".env.production"
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªãã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã«ã—ãªã„ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯ç’°å¢ƒå¤‰æ•°ãŒç›´æ¥è¨­å®šã•ã‚Œã‚‹ï¼‰
	if err := godotenv.Load(envFile); err != nil {
		log.Printf("Info: .env file not loaded (%s), using system environment variables", envFile)
	} else {
		log.Printf("âœ… Loaded environment from %s", envFile)
	}

	// YouTube API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
	youtubeAPIKey := os.Getenv("YOUTUBE_API_KEY")
	if youtubeAPIKey == "" {
		log.Fatal("YOUTUBE_API_KEY environment variable is not set")
	}

	youtubeClient, err := youtube.NewClient(youtubeAPIKey)
	if err != nil {
		log.Fatalf("Failed to create YouTube client: %v", err)
	}
	fmt.Println("âœ… YouTube API client initialized successfully!")

	dbUrl := os.Getenv("DATABASE_URL")
	if dbUrl == "" {
		log.Fatal("DATABASE_URL environment variable is not set")
	}

	// DBæ¥ç¶š
	pool, err := pgxpool.New(context.Background(), dbUrl)
	if err != nil {
		log.Fatalf("Unable to connect to database: %v", err)
	}
	defer pool.Close()

	// ç–é€šç¢ºèª
	if err = pool.Ping(context.Background()); err != nil {
		log.Fatalf("Failed to ping database: %v", err)
	}
	fmt.Println("âœ… Connected to CockroachDB successfully!")

	// â˜…ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆ: DBæ¥ç¶šã‚’ä½¿ã£ã¦ sqlc ã® Queries ã‚’ä½œæˆ
	queries := db.New(pool)

	// ã‚µãƒ¼ãƒãƒ¼ã«æ¸¡ã™
	server := &TimelineServer{
		queries: queries,
		youtube: youtubeClient,
	}

	path, handler := pixicastv1connect.NewTimelineServiceHandler(server)
	
	// CORSãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’è¿½åŠ 
	corsHandler := func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Connect-Protocol-Version, Connect-Timeout-Ms")
			w.Header().Set("Access-Control-Expose-Headers", "Connect-Protocol-Version, Connect-Timeout-Ms")
			
			// ãƒ—ãƒªãƒ•ãƒ©ã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¯¾å¿œ
			if r.Method == "OPTIONS" {
				w.WriteHeader(http.StatusOK)
				return
			}
			
			h.ServeHTTP(w, r)
		})
	}
	
	// Subscription ãƒãƒ³ãƒ‰ãƒ©ã‚’ä½œæˆ
	subscriptionHandler := handlers.NewSubscriptionHandler(queries, youtubeClient)
	
	mux := http.NewServeMux()
	mux.Handle(path, corsHandler(handler))
	
	// REST APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
	mux.HandleFunc("/v1/subscriptions", func(w http.ResponseWriter, r *http.Request) {
		// CORSå‡¦ç†
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}
		
		if r.Method == "GET" {
			subscriptionHandler.ListSubscriptions(w, r)
			return
		}
		
		if r.Method == "POST" {
			subscriptionHandler.CreateSubscription(w, r)
			return
		}
		
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})
	
	// DELETE /v1/subscriptions/{channelId}
	mux.HandleFunc("/v1/subscriptions/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "DELETE" || r.Method == "OPTIONS" {
			subscriptionHandler.DeleteSubscription(w, r)
			return
		}
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	addr := ":" + port

	fmt.Printf("Starting Pixicast Server (Timeline Mode) on %s ...\n", addr)
	err = http.ListenAndServe(
		addr,
		h2c.NewHandler(mux, &http2.Server{}),
	)
	if err != nil {
		log.Fatalf("Server failed: %v", err)
	}
}